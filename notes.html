<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Notes Vocales - Actu & M√©dia</title>
    <meta name="description" content="Dictaphone et notes vocales avec transcription automatique">
    <meta name="theme-color" content="#0a0a14">
    
    <link rel="icon" type="image/png" sizes="192x192" href="/icons/icon-192.png">
    <link rel="apple-touch-icon" href="/icons/icon-192.png">
    <link rel="manifest" href="/manifest.json">
    
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <style>
        :root {
            --bg-body: #0a0a14;
            --bg-card: rgba(255, 255, 255, 0.05);
            --bg-elevated: rgba(255, 255, 255, 0.08);
            --bg-hover: rgba(255, 255, 255, 0.12);
            --border: rgba(255, 255, 255, 0.1);
            --text: #f0f0f5;
            --text-secondary: rgba(255, 255, 255, 0.65);
            --text-muted: rgba(255, 255, 255, 0.4);
            --primary: #6366f1;
            --primary-light: #818cf8;
            --accent-red: #ef4444;
            --accent-red-glow: rgba(239, 68, 68, 0.3);
            --accent-green: #10b981;
            --accent-amber: #f59e0b;
            --radius: 16px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'DM Sans', -apple-system, sans-serif;
            background: var(--bg-body);
            color: var(--text);
            min-height: 100vh;
            min-height: 100dvh;
            overflow-x: hidden;
        }

        .app-header {
            position: sticky;
            top: 0;
            z-index: 100;
            background: rgba(10, 10, 20, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border);
            padding: 12px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header-left { display: flex; align-items: center; gap: 12px; }

        .back-btn {
            width: 38px; height: 38px; border-radius: 12px;
            background: var(--bg-card); border: 1px solid var(--border);
            color: var(--text); display: flex; align-items: center; justify-content: center;
            cursor: pointer; text-decoration: none; transition: all 0.2s;
        }
        .back-btn:hover { background: var(--bg-hover); }

        .app-title { font-size: 1.15rem; font-weight: 700; }
        .app-title span { color: var(--primary-light); }

        .header-right { display: flex; gap: 8px; }

        .header-btn {
            width: 38px; height: 38px; border-radius: 12px;
            background: var(--bg-card); border: 1px solid var(--border);
            color: var(--text-secondary); display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s;
        }
        .header-btn:hover { background: var(--bg-hover); color: var(--text); }
        .header-btn .material-icons { font-size: 20px; }

        .app-main { max-width: 600px; margin: 0 auto; padding: 20px 16px 140px; }

        .recorder-zone {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius); padding: 24px; margin-bottom: 24px; text-align: center;
        }
        .recorder-zone.recording { border-color: var(--accent-red); box-shadow: 0 0 30px var(--accent-red-glow); }

        .audio-visualizer {
            height: 60px; display: flex; align-items: center; justify-content: center;
            gap: 3px; margin-bottom: 16px; opacity: 0.3; transition: opacity 0.3s;
        }
        .recorder-zone.recording .audio-visualizer { opacity: 1; }

        .viz-bar {
            width: 4px; height: 8px; background: var(--primary-light);
            border-radius: 4px; transition: height 0.08s ease;
        }
        .recorder-zone.recording .viz-bar { background: var(--accent-red); }

        .record-timer {
            font-size: 2rem; font-weight: 700; font-variant-numeric: tabular-nums;
            color: var(--text-muted); margin-bottom: 16px; transition: color 0.3s;
        }
        .recorder-zone.recording .record-timer { color: var(--accent-red); }

        .record-controls { display: flex; align-items: center; justify-content: center; gap: 16px; }

        .record-btn {
            width: 72px; height: 72px; border-radius: 50%;
            border: 3px solid var(--accent-red); background: transparent;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all 0.3s;
        }
        .record-btn-inner {
            width: 44px; height: 44px; background: var(--accent-red);
            border-radius: 50%; transition: all 0.3s;
        }
        .record-btn:hover { transform: scale(1.08); box-shadow: 0 0 20px var(--accent-red-glow); }
        .recorder-zone.recording .record-btn-inner { width: 28px; height: 28px; border-radius: 6px; }

        .record-label { font-size: 0.8rem; color: var(--text-muted); margin-top: 12px; }
        .recorder-zone.recording .record-label { color: var(--accent-red); }

        .speech-status { display: none; font-size: 0.75rem; color: var(--text-muted); margin-top: 8px; }

        .live-transcription {
            display: none; margin-top: 20px; padding: 16px;
            background: var(--bg-elevated); border-radius: 12px;
            border: 1px solid var(--border); text-align: left;
        }
        .live-transcription.active { display: block; }

        .live-transcription-label {
            font-size: 0.7rem; font-weight: 600; text-transform: uppercase;
            letter-spacing: 1px; color: var(--accent-green); margin-bottom: 8px;
            display: flex; align-items: center; gap: 6px;
        }
        .live-transcription-label .pulse {
            width: 8px; height: 8px; background: var(--accent-green);
            border-radius: 50%; animation: pulse 1.5s ease-in-out infinite;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

        .live-text { font-size: 0.95rem; line-height: 1.6; color: var(--text); min-height: 40px; }
        .live-text .interim { color: var(--text-muted); font-style: italic; }

        .browser-warning {
            display: none; padding: 14px 16px;
            background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: var(--radius); margin-bottom: 20px;
            font-size: 0.85rem; color: var(--accent-amber); line-height: 1.5;
        }
        .browser-warning .material-icons { font-size: 18px; vertical-align: middle; margin-right: 6px; }

        .notes-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; }
        .notes-title { font-size: 1rem; font-weight: 700; display: flex; align-items: center; gap: 8px; }
        .notes-count { font-size: 0.75rem; background: var(--bg-elevated); color: var(--text-muted); padding: 2px 10px; border-radius: 20px; }

        .notes-empty { text-align: center; padding: 48px 20px; color: var(--text-muted); }
        .notes-empty .material-icons { font-size: 48px; margin-bottom: 12px; opacity: 0.3; }
        .notes-empty p { font-size: 0.9rem; line-height: 1.6; }

        .note-card {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius); padding: 16px; margin-bottom: 12px;
            transition: all 0.2s; animation: fadeInUp 0.3s ease;
        }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .note-card:hover { border-color: var(--primary); background: var(--bg-elevated); }

        .note-card-header { display: flex; align-items: flex-start; justify-content: space-between; margin-bottom: 10px; }

        .note-type-badge {
            display: inline-flex; align-items: center; gap: 4px;
            font-size: 0.7rem; font-weight: 600; text-transform: uppercase;
            letter-spacing: 0.5px; padding: 3px 10px; border-radius: 20px;
        }
        .note-type-badge.voice { background: rgba(239, 68, 68, 0.15); color: var(--accent-red); }
        .note-type-badge.text { background: rgba(99, 102, 241, 0.15); color: var(--primary-light); }
        .note-type-badge .material-icons { font-size: 14px; }

        .note-date { font-size: 0.75rem; color: var(--text-muted); }
        .note-content { font-size: 0.9rem; line-height: 1.6; color: var(--text-secondary); margin-bottom: 12px; word-break: break-word; }

        .note-audio-player {
            display: flex; align-items: center; gap: 10px;
            padding: 10px 14px; background: var(--bg-elevated);
            border-radius: 12px; margin-bottom: 12px;
        }
        .note-play-btn {
            width: 36px; height: 36px; border-radius: 50%;
            background: var(--primary); border: none; color: white;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; flex-shrink: 0; transition: all 0.2s;
        }
        .note-play-btn:hover { background: var(--primary-light); transform: scale(1.1); }
        .note-play-btn .material-icons { font-size: 20px; }

        .note-audio-info { flex: 1; min-width: 0; }
        .note-audio-duration { font-size: 0.75rem; color: var(--text-muted); font-variant-numeric: tabular-nums; }
        .note-audio-progress { width: 100%; height: 4px; background: var(--border); border-radius: 4px; margin-top: 4px; overflow: hidden; }
        .note-audio-progress-bar { height: 100%; width: 0%; background: var(--primary); border-radius: 4px; transition: width 0.2s; }

        .note-actions { display: flex; gap: 8px; justify-content: flex-end; }
        .note-action-btn {
            padding: 6px 12px; border-radius: 8px; background: transparent;
            border: 1px solid var(--border); color: var(--text-muted);
            font-size: 0.75rem; font-family: inherit; cursor: pointer;
            display: flex; align-items: center; gap: 4px; transition: all 0.2s;
        }
        .note-action-btn:hover { background: var(--bg-hover); color: var(--text); }
        .note-action-btn.delete:hover { background: rgba(239, 68, 68, 0.1); border-color: var(--accent-red); color: var(--accent-red); }
        .note-action-btn .material-icons { font-size: 16px; }

        .fab-text {
            position: fixed; bottom: 24px; right: 24px;
            width: 56px; height: 56px; border-radius: 16px;
            background: var(--primary); border: none; color: white;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; box-shadow: 0 4px 20px rgba(99, 102, 241, 0.4);
            transition: all 0.3s; z-index: 90;
        }
        .fab-text:hover { transform: translateY(-3px); box-shadow: 0 8px 30px rgba(99, 102, 241, 0.5); }
        .fab-text .material-icons { font-size: 28px; }

        .modal-overlay {
            display: none; position: fixed; inset: 0;
            background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px); z-index: 200;
            align-items: flex-end; justify-content: center;
        }
        .modal-overlay.active { display: flex; }
        .modal-content {
            width: 100%; max-width: 600px; background: #14141f;
            border-radius: 20px 20px 0 0; padding: 24px;
            max-height: 80vh; overflow-y: auto; animation: slideUp 0.3s ease;
        }
        @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
        .modal-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; }
        .modal-title { font-size: 1.1rem; font-weight: 700; }
        .modal-close {
            width: 36px; height: 36px; border-radius: 50%;
            background: var(--bg-elevated); border: none;
            color: var(--text-secondary); display: flex; align-items: center; justify-content: center; cursor: pointer;
        }
        .modal-textarea {
            width: 100%; min-height: 150px; padding: 16px;
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: 12px; color: var(--text); font-family: inherit;
            font-size: 0.95rem; line-height: 1.6; resize: vertical; outline: none; margin-bottom: 16px;
        }
        .modal-textarea:focus { border-color: var(--primary); box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15); }
        .modal-textarea::placeholder { color: var(--text-muted); }
        .modal-save-btn {
            width: 100%; padding: 14px; background: var(--primary); border: none;
            border-radius: 12px; color: white; font-family: inherit;
            font-size: 1rem; font-weight: 600; cursor: pointer;
            display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.2s;
        }
        .modal-save-btn:hover { background: var(--primary-light); }

        .toast {
            position: fixed; bottom: 90px; left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 12px 24px; background: var(--accent-green); color: white;
            border-radius: 12px; font-size: 0.85rem; font-weight: 600;
            z-index: 999; opacity: 0; transition: all 0.3s ease; white-space: nowrap;
        }
        .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }

        .search-bar { display: none; margin-bottom: 16px; position: relative; }
        .search-bar.active { display: block; }
        .search-input {
            width: 100%; padding: 12px 16px 12px 44px;
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: 12px; color: var(--text); font-family: inherit; font-size: 0.9rem; outline: none;
        }
        .search-input:focus { border-color: var(--primary); }
        .search-bar .material-icons { position: absolute; left: 14px; top: 50%; transform: translateY(-50%); color: var(--text-muted); font-size: 20px; }

        @media (max-width: 400px) {
            .app-main { padding: 14px 12px 140px; }
            .recorder-zone { padding: 18px; }
            .record-btn { width: 64px; height: 64px; }
            .record-btn-inner { width: 38px; height: 38px; }
        }
    </style>
</head>
<body>
    <header class="app-header">
        <div class="header-left">
            <a href="index.html" class="back-btn"><span class="material-icons">home</span></a>
            <div class="app-title">üéôÔ∏è Notes <span>Vocales</span></div>
        </div>
        <div class="header-right">
            <button class="header-btn" id="searchToggle" title="Rechercher"><span class="material-icons">search</span></button>
            <button class="header-btn" id="exportBtn" title="Exporter"><span class="material-icons">file_download</span></button>
            <button class="header-btn" id="importBtn" title="Importer"><span class="material-icons">file_upload</span></button>
            <button class="header-btn" id="deleteAllBtn" title="Tout supprimer"><span class="material-icons">delete_sweep</span></button>
            <input type="file" id="importFile" accept=".json" style="display:none">
        </div>
    </header>

    <main class="app-main">
        <div class="browser-warning" id="browserWarning">
            <span class="material-icons">warning</span>
            <strong>Navigateur non compatible :</strong> La transcription vocale n√©cessite Chrome, Edge ou Safari.
        </div>

        <div class="recorder-zone" id="recorderZone">
            <div class="audio-visualizer" id="visualizer">
                <div class="viz-bar"></div><div class="viz-bar"></div><div class="viz-bar"></div>
                <div class="viz-bar"></div><div class="viz-bar"></div><div class="viz-bar"></div>
                <div class="viz-bar"></div><div class="viz-bar"></div><div class="viz-bar"></div>
                <div class="viz-bar"></div><div class="viz-bar"></div><div class="viz-bar"></div>
                <div class="viz-bar"></div><div class="viz-bar"></div><div class="viz-bar"></div>
            </div>
            <div class="record-timer" id="recordTimer">00:00</div>
            <div class="record-controls">
                <button class="record-btn" id="recordBtn" title="Enregistrer">
                    <div class="record-btn-inner"></div>
                </button>
            </div>
            <div class="record-label" id="recordLabel">Appuyez pour enregistrer</div>
            <div class="speech-status" id="speechStatus"></div>
            <div class="live-transcription" id="liveTranscription">
                <div class="live-transcription-label"><span class="pulse"></span> Transcription en cours</div>
                <div class="live-text" id="liveText"></div>
            </div>
        </div>

        <div class="search-bar" id="searchBar">
            <span class="material-icons">search</span>
            <input type="text" class="search-input" id="searchInput" placeholder="Rechercher dans les notes...">
        </div>

        <div class="notes-header">
            <div class="notes-title">üìù Mes notes <span class="notes-count" id="notesCount">0</span></div>
        </div>
        <div id="notesList"></div>
        <div class="notes-empty" id="notesEmpty">
            <span class="material-icons">mic_none</span>
            <p>Aucune note pour l'instant.<br>Appuyez sur le micro pour enregistrer<br>ou sur ‚úèÔ∏è pour √©crire une note.</p>
        </div>
    </main>

    <button class="fab-text" id="fabText" title="Nouvelle note √©crite"><span class="material-icons">edit_note</span></button>

    <div class="modal-overlay" id="textModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">‚úèÔ∏è Nouvelle note</div>
                <button class="modal-close" id="modalClose"><span class="material-icons">close</span></button>
            </div>
            <textarea class="modal-textarea" id="modalTextarea" placeholder="√âcrivez votre note ici..."></textarea>
            <button class="modal-save-btn" id="modalSave"><span class="material-icons">save</span> Enregistrer la note</button>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
    // ===================================================================
    // DATABASE (IndexedDB)
    // ===================================================================
    class NotesDB {
        constructor() { this.dbName = 'actuetmedia_notes'; this.dbVersion = 1; this.db = null; }

        async init() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(this.dbName, this.dbVersion);
                req.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('notes'))
                        db.createObjectStore('notes', { keyPath: 'id' }).createIndex('date', 'date');
                };
                req.onsuccess = (e) => { this.db = e.target.result; resolve(); };
                req.onerror = () => reject(req.error);
            });
        }

        async save(note) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction('notes', 'readwrite');
                tx.objectStore('notes').put(note);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        async getAll() {
            return new Promise((resolve, reject) => {
                const req = this.db.transaction('notes', 'readonly').objectStore('notes').getAll();
                req.onsuccess = () => resolve(req.result.sort((a, b) => b.date - a.date));
                req.onerror = () => reject(req.error);
            });
        }

        async delete(id) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction('notes', 'readwrite');
                tx.objectStore('notes').delete(id);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        async deleteAll() {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction('notes', 'readwrite');
                tx.objectStore('notes').clear();
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }
    }

    // ===================================================================
    // WAV ENCODER - Enregistre via AudioContext (ne bloque PAS le micro)
    // ===================================================================
    class WavRecorder {
        constructor(stream) {
            this.stream = stream;
            this.audioContext = null;
            this.sourceNode = null;
            this.processorNode = null;
            this.analyserNode = null;
            this.chunks = [];
            this.recording = false;
        }

        start() {
            // Utiliser le sampleRate natif de l'appareil pour √©viter les probl√®mes
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.sourceNode = this.audioContext.createMediaStreamSource(this.stream);
            
            // Analyser pour le visualiseur
            this.analyserNode = this.audioContext.createAnalyser();
            this.analyserNode.fftSize = 64;
            this.sourceNode.connect(this.analyserNode);

            // Capturer les √©chantillons bruts
            this.processorNode = this.audioContext.createScriptProcessor(4096, 1, 1);
            this.chunks = [];
            this.recording = true;

            this.processorNode.onaudioprocess = (e) => {
                if (!this.recording) return;
                this.chunks.push(new Float32Array(e.inputBuffer.getChannelData(0)));
            };

            this.sourceNode.connect(this.processorNode);
            this.processorNode.connect(this.audioContext.destination);
        }

        stop() {
            this.recording = false;
            try {
                this.processorNode.disconnect();
                this.sourceNode.disconnect();
            } catch(e) {}
            
            const sampleRate = this.audioContext.sampleRate;
            
            try { this.audioContext.close(); } catch(e) {}
            return this.encodeWav(sampleRate);
        }

        encodeWav(sampleRate) {
            const totalLength = this.chunks.reduce((a, c) => a + c.length, 0);
            const merged = new Float32Array(totalLength);
            let offset = 0;
            for (const chunk of this.chunks) { merged.set(chunk, offset); offset += chunk.length; }

            // Sous-√©chantillonner √† 16kHz pour r√©duire la taille
            const targetRate = 16000;
            const ratio = sampleRate / targetRate;
            const newLength = Math.floor(merged.length / ratio);
            const downsampled = new Float32Array(newLength);
            for (let i = 0; i < newLength; i++) {
                downsampled[i] = merged[Math.floor(i * ratio)];
            }

            const int16 = new Int16Array(downsampled.length);
            for (let i = 0; i < downsampled.length; i++) {
                const s = Math.max(-1, Math.min(1, downsampled[i]));
                int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }

            const buffer = new ArrayBuffer(44 + int16.length * 2);
            const view = new DataView(buffer);

            const writeStr = (o, s) => { for (let i = 0; i < s.length; i++) view.setUint8(o + i, s.charCodeAt(i)); };
            writeStr(0, 'RIFF');
            view.setUint32(4, 36 + int16.length * 2, true);
            writeStr(8, 'WAVE');
            writeStr(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, targetRate, true);
            view.setUint32(28, targetRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeStr(36, 'data');
            view.setUint32(40, int16.length * 2, true);
            new Int16Array(buffer, 44).set(int16);

            return new Blob([buffer], { type: 'audio/wav' });
        }
    }

    // ===================================================================
    // APP
    // ===================================================================
    const db = new NotesDB();
    let isRecording = false;
    let recordStartTime = 0;
    let timerInterval = null;
    let recognition = null;
    let finalTranscript = '';
    let interimTranscript = '';
    let currentAudio = null;
    let currentPlayBtn = null;
    let wavRecorder = null;
    let micStream = null;
    let vizInterval = null;

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const speechSupported = !!SpeechRecognition;

    const recorderZone = document.getElementById('recorderZone');
    const recordBtn = document.getElementById('recordBtn');
    const recordTimer = document.getElementById('recordTimer');
    const recordLabel = document.getElementById('recordLabel');
    const speechStatus = document.getElementById('speechStatus');
    const liveTranscription = document.getElementById('liveTranscription');
    const liveText = document.getElementById('liveText');
    const notesList = document.getElementById('notesList');
    const notesEmpty = document.getElementById('notesEmpty');
    const notesCount = document.getElementById('notesCount');
    const vizBars = document.querySelectorAll('.viz-bar');

    async function init() {
        await db.init();
        if (!speechSupported) document.getElementById('browserWarning').style.display = 'block';
        renderNotes();
    }

    // ===================================================================
    // ENREGISTREMENT
    // La cl√© : SpeechRecognition ouvre son PROPRE acc√®s micro en interne.
    // On utilise Web Audio API (lecture seule du flux) au lieu de MediaRecorder.
    // ===================================================================
    recordBtn.addEventListener('click', () => isRecording ? stopRecording() : startRecording());

    async function startRecording() {
        try {
            finalTranscript = '';
            interimTranscript = '';

            // 1. D'abord d√©marrer SpeechRecognition (il prend le micro en interne)
            if (speechSupported) {
                startSpeechRecognition();
                // Petit d√©lai pour laisser la reconnaissance s'initialiser
                await new Promise(r => setTimeout(r, 500));
            }

            // 2. Ensuite getUserMedia pour notre enregistrement audio
            micStream = await navigator.mediaDevices.getUserMedia({
                audio: { echoCancellation: false, noiseSuppression: false, channelCount: 1 }
            });

            // 3. Enregistrer via Web Audio API (pas MediaRecorder !)
            wavRecorder = new WavRecorder(micStream);
            wavRecorder.start();

            isRecording = true;
            recordStartTime = Date.now();

            // 4. Visualiseur
            startVisualizer();

            // UI
            recorderZone.classList.add('recording');
            recordLabel.textContent = 'Appuyez pour arr√™ter';
            startTimer();

        } catch (err) {
            console.error('Erreur micro:', err);
            showToast('‚ö†Ô∏è Acc√®s au micro refus√©');
            if (recognition) { try { recognition.abort(); } catch(e) {} }
        }
    }

    function stopRecording() {
        isRecording = false;
        recorderZone.classList.remove('recording');
        recordLabel.textContent = 'Appuyez pour enregistrer';
        stopTimer();
        stopVisualizer();

        // Arr√™ter transcription
        if (recognition) { try { recognition.abort(); } catch(e) {} recognition = null; }
        liveTranscription.classList.remove('active');
        speechStatus.style.display = 'none';

        // R√©cup√©rer l'audio WAV
        let audioBlob = null;
        if (wavRecorder) {
            audioBlob = wavRecorder.stop();
            wavRecorder = null;
        }

        // Lib√©rer le micro
        if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }

        // Sauvegarder
        if (audioBlob) saveVoiceNote(audioBlob);
    }

    // ===================================================================
    // VISUALIZER
    // ===================================================================
    function startVisualizer() {
        if (!wavRecorder || !wavRecorder.analyserNode) return;
        const analyser = wavRecorder.analyserNode;
        const dataArray = new Uint8Array(analyser.frequencyBinCount);

        vizInterval = setInterval(() => {
            analyser.getByteFrequencyData(dataArray);
            vizBars.forEach((bar, i) => {
                const val = dataArray[i * 2] || 0;
                bar.style.height = Math.max(8, (val / 255) * 55) + 'px';
            });
        }, 60);
    }

    function stopVisualizer() {
        clearInterval(vizInterval);
        vizBars.forEach(bar => bar.style.height = '8px');
    }

    // ===================================================================
    // SPEECH RECOGNITION
    // ===================================================================
    function startSpeechRecognition() {
        speechStatus.style.display = 'block';
        speechStatus.textContent = '‚è≥ Initialisation transcription...';
        speechStatus.style.color = 'var(--text-muted)';

        try {
            recognition = new SpeechRecognition();
            recognition.lang = 'fr-FR';
            recognition.continuous = true;
            recognition.interimResults = true;

            recognition.onstart = () => {
                speechStatus.textContent = 'üé§ Transcription active ‚Äî parlez...';
                speechStatus.style.color = 'var(--accent-green)';
                liveTranscription.classList.add('active');
                liveText.innerHTML = '<span class="interim">En √©coute...</span>';
            };

            recognition.onresult = (e) => {
                interimTranscript = '';
                for (let i = e.resultIndex; i < e.results.length; i++) {
                    const t = e.results[i][0].transcript;
                    if (e.results[i].isFinal) finalTranscript += t + ' ';
                    else interimTranscript = t;
                }
                liveText.innerHTML = finalTranscript + '<span class="interim">' + interimTranscript + '</span>';
            };

            recognition.onerror = (e) => {
                console.warn('Erreur transcription:', e.error);
                const msgs = {
                    'not-allowed': '‚ùå Micro refus√©',
                    'network': '‚ùå Internet requis',
                    'no-speech': 'üé§ Aucune voix d√©tect√©e...',
                    'audio-capture': '‚ùå Micro d√©j√† utilis√©'
                };
                if (msgs[e.error]) {
                    speechStatus.textContent = msgs[e.error];
                    speechStatus.style.color = e.error === 'no-speech' ? 'var(--accent-amber)' : 'var(--accent-red)';
                }
            };

            recognition.onend = () => {
                if (isRecording) {
                    setTimeout(() => {
                        if (!isRecording) return;
                        try { recognition.start(); }
                        catch(e) { speechStatus.textContent = '‚ö†Ô∏è Transcription interrompue'; }
                    }, 300);
                }
            };

            recognition.start();
        } catch (e) {
            speechStatus.textContent = '‚ùå Non disponible';
            speechStatus.style.color = 'var(--accent-red)';
        }
    }

    // ===================================================================
    // TIMER
    // ===================================================================
    function startTimer() {
        recordTimer.textContent = '00:00';
        timerInterval = setInterval(() => {
            const s = Math.floor((Date.now() - recordStartTime) / 1000);
            recordTimer.textContent = String(Math.floor(s / 60)).padStart(2, '0') + ':' + String(s % 60).padStart(2, '0');
        }, 200);
    }
    function stopTimer() { clearInterval(timerInterval); }

    // ===================================================================
    // SAVE
    // ===================================================================
    async function saveVoiceNote(audioBlob) {
        const duration = Math.floor((Date.now() - recordStartTime) / 1000);
        const text = (finalTranscript + interimTranscript).trim();

        const reader = new FileReader();
        reader.onload = async () => {
            await db.save({
                id: 'note_' + Date.now(),
                type: 'voice',
                text: text || '(Aucune transcription)',
                audioData: reader.result,
                duration, date: Date.now()
            });
            renderNotes();
            showToast('üéôÔ∏è Note vocale enregistr√©e');
            finalTranscript = ''; interimTranscript = '';
            liveText.innerHTML = ''; recordTimer.textContent = '00:00';
        };
        reader.readAsDataURL(audioBlob);
    }

    document.getElementById('modalSave').addEventListener('click', async () => {
        const text = document.getElementById('modalTextarea').value.trim();
        if (!text) return;
        await db.save({ id: 'note_' + Date.now(), type: 'text', text, date: Date.now() });
        renderNotes();
        showToast('üìù Note enregistr√©e');
        document.getElementById('modalTextarea').value = '';
        document.getElementById('textModal').classList.remove('active');
    });

    // ===================================================================
    // RENDER
    // ===================================================================
    async function renderNotes(filter = '') {
        let notes = await db.getAll();
        if (filter) { const q = filter.toLowerCase(); notes = notes.filter(n => n.text.toLowerCase().includes(q)); }

        notesCount.textContent = notes.length;
        notesEmpty.style.display = notes.length === 0 ? 'block' : 'none';

        notesList.innerHTML = notes.map(note => {
            const dateStr = formatDate(note.date);
            const icon = note.type === 'voice' ? 'mic' : 'edit_note';
            const label = note.type === 'voice' ? 'Vocal' : 'Texte';
            const cls = note.type === 'voice' ? 'voice' : 'text';

            let audioHTML = '';
            if (note.type === 'voice' && note.audioData) {
                audioHTML = `
                    <div class="note-audio-player">
                        <button class="note-play-btn" onclick="playAudio('${note.id}', this)" data-audio="${note.audioData}">
                            <span class="material-icons">play_arrow</span>
                        </button>
                        <div class="note-audio-info">
                            <div class="note-audio-duration">${formatDuration(note.duration)}</div>
                            <div class="note-audio-progress"><div class="note-audio-progress-bar" id="prog_${note.id}"></div></div>
                        </div>
                    </div>`;
            }

            const txt = note.text.length > 200 ? note.text.substring(0, 200) + '...' : note.text;

            return `
                <div class="note-card" id="card_${note.id}">
                    <div class="note-card-header">
                        <span class="note-type-badge ${cls}"><span class="material-icons">${icon}</span> ${label}</span>
                        <span class="note-date">${dateStr}</span>
                    </div>
                    ${audioHTML}
                    <div class="note-content">${escapeHTML(txt)}</div>
                    <div class="note-actions">
                        <button class="note-action-btn" onclick="copyNote('${note.id}')"><span class="material-icons">content_copy</span> Copier</button>
                        <button class="note-action-btn" onclick="shareNote('${note.id}')"><span class="material-icons">share</span></button>
                        <button class="note-action-btn delete" onclick="deleteNote('${note.id}')"><span class="material-icons">delete</span></button>
                    </div>
                </div>`;
        }).join('');
    }

    // ===================================================================
    // PLAYBACK
    // ===================================================================
    function playAudio(noteId, btn) {
        const src = btn.dataset.audio;
        const prog = document.getElementById('prog_' + noteId);

        if (currentPlayBtn === btn && currentAudio) {
            if (!currentAudio.paused) {
                currentAudio.pause();
                btn.innerHTML = '<span class="material-icons">play_arrow</span>';
                return;
            } else {
                currentAudio.play();
                btn.innerHTML = '<span class="material-icons">pause</span>';
                return;
            }
        }

        if (currentAudio) {
            currentAudio.pause(); currentAudio.currentTime = 0;
            if (currentPlayBtn) currentPlayBtn.innerHTML = '<span class="material-icons">play_arrow</span>';
        }

        const audio = new Audio(src);
        currentAudio = audio; currentPlayBtn = btn;
        btn.innerHTML = '<span class="material-icons">pause</span>';

        audio.ontimeupdate = () => { if (audio.duration && prog) prog.style.width = (audio.currentTime / audio.duration * 100) + '%'; };
        audio.onended = () => {
            btn.innerHTML = '<span class="material-icons">play_arrow</span>';
            if (prog) prog.style.width = '0%';
            currentAudio = null; currentPlayBtn = null;
        };
        audio.play();
    }

    // ===================================================================
    // ACTIONS
    // ===================================================================
    async function copyNote(id) {
        const notes = await db.getAll();
        const n = notes.find(n => n.id === id);
        if (n) { await navigator.clipboard.writeText(n.text); showToast('üìã Copi√©'); }
    }

    async function shareNote(id) {
        const notes = await db.getAll();
        const n = notes.find(n => n.id === id);
        if (n && navigator.share) { try { await navigator.share({ text: n.text }); } catch(e) {} }
        else if (n) { await navigator.clipboard.writeText(n.text); showToast('üìã Copi√©'); }
    }

    async function deleteNote(id) {
        if (!confirm('Supprimer cette note ?')) return;
        if (currentAudio) { currentAudio.pause(); currentAudio = null; currentPlayBtn = null; }
        await db.delete(id);
        const card = document.getElementById('card_' + id);
        if (card) { card.style.opacity = '0'; card.style.transform = 'translateX(100px)'; card.style.transition = 'all 0.3s'; }
        setTimeout(() => renderNotes(), 300);
        showToast('üóëÔ∏è Supprim√©e');
    }

    document.getElementById('deleteAllBtn').addEventListener('click', async () => {
        const notes = await db.getAll();
        if (!notes.length) return;
        if (!confirm(`Supprimer les ${notes.length} note(s) ?`)) return;
        if (!confirm('Irr√©versible. Confirmer ?')) return;
        if (currentAudio) { currentAudio.pause(); currentAudio = null; }
        await db.deleteAll(); renderNotes(); showToast('üóëÔ∏è Tout supprim√©');
    });

    // ===================================================================
    // EXPORT / IMPORT
    // ===================================================================
    document.getElementById('exportBtn').addEventListener('click', async () => {
        const notes = await db.getAll();
        if (!notes.length) { showToast('‚ö†Ô∏è Aucune note'); return; }
        const blob = new Blob([JSON.stringify({ app: 'ActuetMedia Notes', v: 1, date: new Date().toISOString(), notes })], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `notes-vocales-${new Date().toISOString().slice(0, 10)}.json`;
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        showToast(`üì¶ ${notes.length} note(s) export√©e(s)`);
    });

    document.getElementById('importBtn').addEventListener('click', () => document.getElementById('importFile').click());

    document.getElementById('importFile').addEventListener('change', async (e) => {
        const file = e.target.files[0]; if (!file) return;
        try {
            const data = JSON.parse(await file.text());
            if (!data.notes?.length) { showToast('‚ö†Ô∏è Fichier invalide'); return; }
            const existing = new Set((await db.getAll()).map(n => n.id));
            let ok = 0, skip = 0;
            for (const n of data.notes) {
                if (!n.id || !n.type || !n.text) continue;
                if (existing.has(n.id)) { skip++; continue; }
                await db.save(n); ok++;
            }
            renderNotes();
            showToast(`üì• ${ok} import√©e(s)` + (skip ? ` (${skip} doublon(s))` : ''));
        } catch(err) { showToast('‚ö†Ô∏è Erreur import'); }
        e.target.value = '';
    });

    // ===================================================================
    // MODAL / SEARCH
    // ===================================================================
    document.getElementById('fabText').addEventListener('click', () => {
        document.getElementById('textModal').classList.add('active');
        document.getElementById('modalTextarea').focus();
    });
    document.getElementById('modalClose').addEventListener('click', () => document.getElementById('textModal').classList.remove('active'));
    document.getElementById('textModal').addEventListener('click', (e) => {
        if (e.target.id === 'textModal') document.getElementById('textModal').classList.remove('active');
    });

    document.getElementById('searchToggle').addEventListener('click', () => {
        const bar = document.getElementById('searchBar');
        bar.classList.toggle('active');
        if (bar.classList.contains('active')) document.getElementById('searchInput').focus();
        else { document.getElementById('searchInput').value = ''; renderNotes(); }
    });
    document.getElementById('searchInput').addEventListener('input', (e) => renderNotes(e.target.value));

    // ===================================================================
    // HELPERS
    // ===================================================================
    function formatDate(ts) {
        const d = new Date(ts), now = new Date(), diff = now - d;
        if (diff < 60000) return '√Ä l\'instant';
        if (diff < 3600000) return `Il y a ${Math.floor(diff / 60000)} min`;
        if (diff < 86400000 && d.getDate() === now.getDate())
            return 'Aujourd\'hui ' + d.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
        return d.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' });
    }

    function formatDuration(s) {
        return String(Math.floor(s / 60)).padStart(2, '0') + ':' + String(s % 60).padStart(2, '0');
    }

    function escapeHTML(t) { const d = document.createElement('div'); d.textContent = t; return d.innerHTML; }

    function showToast(msg) {
        const t = document.getElementById('toast');
        t.textContent = msg; t.classList.add('show');
        setTimeout(() => t.classList.remove('show'), 2500);
    }

    init();
    </script>
</body>
</html>